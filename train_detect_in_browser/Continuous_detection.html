<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Digital Display OCR</title>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<style>
  *, *::before, *::after { box-sizing: border-box; }

  body {
    margin: 0;
    padding: 0;
    background: #0a0a0a;
    color: #e0e0e0;
    font-family: 'Courier New', monospace;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  /* ── PAGE 1: SETUP ── */
  #setup-page {
    width: 100%;
    max-width: 480px;
    padding: 20px 16px 30px;
    display: flex;
    flex-direction: column;
    gap: 0;
  }

  #setup-page h1 {
    font-size: 1rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: #aaffcc;
    margin: 0 0 4px;
    text-align: center;
  }

  #setup-page .sub {
    font-size: 0.68rem;
    color: #557766;
    text-align: center;
    margin-bottom: 20px;
    letter-spacing: 0.05em;
  }

  .meter-row {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 0;
    border-bottom: 1px solid #1a2e1a;
  }

  .meter-num {
    font-size: 0.7rem;
    color: #336644;
    width: 22px;
    text-align: right;
    flex-shrink: 0;
    font-weight: bold;
  }

  .meter-input {
    flex: 1;
    background: #101e10;
    border: 1px solid #224422;
    border-radius: 4px;
    color: #00ff88;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
    padding: 8px 10px;
    outline: none;
    letter-spacing: 0.05em;
    text-transform: uppercase;
    transition: border-color 0.2s;
  }

  .meter-input:focus {
    border-color: #00cc66;
    background: #152215;
  }

  .meter-input::placeholder {
    color: #2a4a2a;
    text-transform: none;
  }

  #start-btn {
    margin-top: 24px;
    width: 100%;
    padding: 14px;
    background: #0a2a0a;
    border: 2px solid #00cc66;
    color: #00ff88;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
    font-weight: bold;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    cursor: pointer;
    border-radius: 6px;
    transition: background 0.2s;
  }

  #start-btn:active { background: #00ff8833; }

  /* ── PAGE 2: OCR ── */
  #ocr-page { display: none; width: 100%; flex-direction: column; align-items: center; }

  /* Header */
  #ocr-header {
    width: 100%;
    max-width: 480px;
    display: flex;
    align-items: center;
    padding: 8px 12px;
    gap: 8px;
    border-bottom: 1px solid #1a3a1a;
    background: #0d1a0d;
  }

  #back-btn {
    background: transparent;
    border: 1px solid #336644;
    color: #557766;
    font-family: 'Courier New', monospace;
    font-size: 0.7rem;
    padding: 5px 8px;
    border-radius: 4px;
    cursor: pointer;
    flex-shrink: 0;
    -webkit-tap-highlight-color: transparent;
  }
  #back-btn:active { background: #00ff8822; }

  #meter-name-display {
    flex: 1;
    text-align: center;
    font-size: 0.95rem;
    font-weight: bold;
    color: #00ff88;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  #meter-counter {
    font-size: 0.65rem;
    color: #336644;
    flex-shrink: 0;
    letter-spacing: 0.05em;
  }

  /* Meter nav dots */
  #meter-nav {
    display: flex;
    gap: 6px;
    padding: 8px 12px;
    width: 100%;
    max-width: 480px;
    justify-content: center;
    flex-wrap: wrap;
    background: #0a0a0a;
  }

  .meter-dot {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: 2px solid #224422;
    background: #101e10;
    color: #336644;
    font-family: 'Courier New', monospace;
    font-size: 0.65rem;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
    -webkit-tap-highlight-color: transparent;
    flex-shrink: 0;
  }

  .meter-dot.active {
    border-color: #00cc66;
    background: #152215;
    color: #00ff88;
  }

  .meter-dot.has-value {
    border-color: #00884a;
    color: #00cc66;
  }

  .meter-dot.active.has-value {
    border-color: #00ff88;
    background: #152215;
    color: #00ff88;
  }

  /* ── Camera ── */
  #cam-wrapper {
    position: relative;
    width: 100vw;
    max-width: 480px;
  }

  #video {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    background: #000;
  }

  #overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: auto;
    touch-action: none;
  }

  /* ── Controls ── */
  #controls {
    display: flex;
    gap: 8px;
    padding: 10px 12px;
    width: 100%;
    max-width: 480px;
  }

  button {
    flex: 1;
    padding: 13px 4px;
    background: #1a2e1a;
    border: 2px solid #00cc66;
    color: #00ff88;
    font-family: 'Courier New', monospace;
    font-size: 0.82rem;
    font-weight: bold;
    letter-spacing: 0.05em;
    text-transform: uppercase;
    cursor: pointer;
    border-radius: 6px;
    transition: background 0.15s, border-color 0.15s;
    -webkit-tap-highlight-color: transparent;
    text-shadow: 0 0 8px #00ff8866;
  }

  button:active { background: #00ff8833; border-color: #00ff88; }
  button.active  { background: #00441a; border-color: #00ff88; color: #ffffff; }

  /* ── Output box ── */
  #output-box {
    width: 100%;
    max-width: 480px;
    padding: 12px 14px 16px;
    border-top: 2px solid #00cc6644;
    background: #0f1f0f;
  }

  #status {
    font-size: 0.78rem;
    color: #88cc99;
    margin-bottom: 10px;
    min-height: 1.2em;
    letter-spacing: 0.05em;
  }

  #output-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 10px;
    background: #152215;
    border: 2px solid #00cc66;
    border-radius: 6px;
    padding: 8px 10px;
  }

  #output-label {
    font-size: 0.65rem;
    color: #55aa77;
    white-space: nowrap;
    letter-spacing: 0.12em;
    font-weight: bold;
  }

  #output {
    flex: 1;
    font-size: 1.6rem;
    font-weight: bold;
    color: #00ff88;
    background: transparent;
    border: none;
    outline: none;
    font-family: 'Courier New', monospace;
    min-width: 0;
    padding: 0 4px;
    caret-color: #00ff88;
  }

  #output::placeholder { color: #336644; font-size: 1.2rem; }

  #copy-btn {
    flex: none;
    padding: 8px 12px;
    font-size: 0.78rem;
    font-weight: bold;
    background: #0a2a0a;
    border: 2px solid #00cc66;
    color: #00ff88;
    border-radius: 5px;
    letter-spacing: 0;
    white-space: nowrap;
  }

  #copy-btn:active, #copy-btn.copied {
    background: #00ff8833;
    border-color: #00ff88;
    color: #ffffff;
  }

  #hint {
    font-size: 0.72rem;
    color: #668877;
    min-height: 1.1em;
    letter-spacing: 0.03em;
    padding: 2px 2px;
  }

  #canvas { display: none; }

  .scanning #status::after {
    content: '';
    animation: dots 1.2s infinite;
  }

  @keyframes dots {
    0%   { content: '.'; }
    33%  { content: '..'; }
    66%  { content: '...'; }
  }
</style>
</head>
<body>

<!-- ═══════════════════════════════════════════════════════ -->
<!--  PAGE 1: SETUP                                         -->
<!-- ═══════════════════════════════════════════════════════ -->
<div id="setup-page">
  <h1>Meter Setup</h1>
  <p class="sub">Enter a name (up to 10 chars) for each meter you want to read</p>

  <div id="meter-list"></div>

  <button id="start-btn" onclick="startOCR()">▶ Start Reading</button>
</div>

<!-- ═══════════════════════════════════════════════════════ -->
<!--  PAGE 2: OCR                                           -->
<!-- ═══════════════════════════════════════════════════════ -->
<div id="ocr-page">

  <div id="ocr-header">
    <button id="back-btn" onclick="goBack()">◀ Setup</button>
    <div id="meter-name-display">—</div>
    <div id="meter-counter">1 / 10</div>
  </div>

  <div id="meter-nav"></div>

  <div id="cam-wrapper">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="controls">
    <button id="btn-torch" onclick="toggleTorch()">⚡ Torch</button>
    <button id="btn-cam"   onclick="switchCamera()">↩ Flip</button>
    <button id="btn-pause" onclick="togglePause()">⏸ Pause</button>
  </div>

  <div id="output-box">
    <div id="status">Starting camera...</div>
    <div id="output-row">
      <span id="output-label">VALUE</span>
      <input id="output" type="text" placeholder="—" autocomplete="off" spellcheck="false" />
      <button id="copy-btn" onclick="copyValue()">⎘ Copy</button>
    </div>
    <div id="hint">Tap a box on the camera to select a number</div>
  </div>

</div>

<canvas id="canvas"></canvas>

<script>
  // ═══════════════════════════════════════════════════════
  //  METER STATE
  // ═══════════════════════════════════════════════════════
  const MAX_METERS = 10;
  let meters       = [];   // [{ name, value }]
  let currentMeter = 0;

  // ─── Build setup inputs ────────────────────────────────
  function buildSetupPage() {
    const list = document.getElementById('meter-list');
    list.innerHTML = '';
    for (let i = 0; i < MAX_METERS; i++) {
      const row = document.createElement('div');
      row.className = 'meter-row';
      row.innerHTML = `
        <span class="meter-num">${i + 1}</span>
        <input class="meter-input" id="m${i}" type="text"
               maxlength="10" placeholder="Meter ${i + 1}"
               autocomplete="off" spellcheck="false"
               oninput="this.value=this.value.toUpperCase().slice(0,10)" />
      `;
      list.appendChild(row);
    }
    // Focus first input
    setTimeout(() => document.getElementById('m0').focus(), 100);
  }

  // ─── Start OCR page ────────────────────────────────────
  function startOCR() {
    // Collect meter names — skip blank ones, fall back to "METER N"
    meters = [];
    for (let i = 0; i < MAX_METERS; i++) {
      const val = (document.getElementById('m' + i).value || '').trim();
      meters.push({ name: val || `METER ${i + 1}`, value: '' });
    }

    document.getElementById('setup-page').style.display = 'none';
    const ocrPage = document.getElementById('ocr-page');
    ocrPage.style.display = 'flex';

    buildMeterNav();
    switchMeter(0);
    startCamera(true);
  }

  // ─── Back to setup ─────────────────────────────────────
  function goBack() {
    // Stop camera
    if (currentStream) { currentStream.getTracks().forEach(t => t.stop()); currentStream = null; }
    if (ocrInterval) { clearInterval(ocrInterval); ocrInterval = null; }

    document.getElementById('ocr-page').style.display = 'none';
    document.getElementById('setup-page').style.display = 'flex';
  }

  // ─── Build meter nav dots ──────────────────────────────
  function buildMeterNav() {
    const nav = document.getElementById('meter-nav');
    nav.innerHTML = '';
    meters.forEach((m, i) => {
      const dot = document.createElement('button');
      dot.className  = 'meter-dot';
      dot.id         = `dot-${i}`;
      dot.title      = m.name;
      dot.textContent = i + 1;
      dot.onclick    = () => switchMeter(i);
      nav.appendChild(dot);
    });
  }

  // ─── Switch active meter ───────────────────────────────
  function switchMeter(idx) {
    // Save current value before switching
    if (meters[currentMeter]) {
      meters[currentMeter].value = outputEl ? outputEl.value : '';
    }

    currentMeter = idx;
    const m = meters[idx];

    // Update header
    document.getElementById('meter-name-display').textContent = m.name;
    document.getElementById('meter-counter').textContent = `${idx + 1} / ${meters.length}`;

    // Update nav dots
    meters.forEach((_, i) => {
      const dot = document.getElementById(`dot-${i}`);
      if (!dot) return;
      dot.className = 'meter-dot' +
        (i === idx ? ' active' : '') +
        (meters[i].value ? ' has-value' : '');
    });

    // Restore value for this meter
    if (outputEl) {
      outputEl.value = m.value || '';
      delete outputEl.dataset.manualEdit;
    }

    // Reset scan state for new meter
    selectedBox = null;
    boxes = [];
    paused = false;
    if (ctxOv) ctxOv.clearRect(0, 0, overlay.width, overlay.height);
    if (statusEl) statusEl.textContent = 'Scanning...';
    if (hintEl) hintEl.textContent = 'Tap a box on the camera to select a number';
    document.getElementById('btn-pause').textContent = '⏸ Pause';
    document.body.classList.add('scanning');
  }

  // ═══════════════════════════════════════════════════════
  //  OCR PAGE ELEMENTS (set after DOM ready)
  // ═══════════════════════════════════════════════════════
  const video      = document.getElementById('video');
  const overlay    = document.getElementById('overlay');
  const ctxOv      = overlay.getContext('2d');
  const canvas     = document.getElementById('canvas');
  const ctx        = canvas.getContext('2d');
  const wrapper    = document.getElementById('cam-wrapper');
  const statusEl   = document.getElementById('status');
  const outputEl   = document.getElementById('output');
  const hintEl     = document.getElementById('hint');

  let boxes        = [];
  let processing   = false;
  let paused       = false;
  let currentStream = null;
  let torchOn      = false;
  let usingRear    = true;
  let ocrInterval  = null;
  let torchTrack   = null;
  let selectedBox  = null;

  // ─── COPY ──────────────────────────────────────────────────────────────────
  function copyValue() {
    const val = outputEl.value.trim();
    if (!val || val === '—') return;
    navigator.clipboard.writeText(val).then(() => {
      const btn = document.getElementById('copy-btn');
      btn.textContent = '✓ Copied';
      btn.classList.add('copied');
      setTimeout(() => { btn.textContent = '⎘ Copy'; btn.classList.remove('copied'); }, 1500);
    }).catch(() => {
      // Fallback for browsers without clipboard API
      outputEl.select();
      document.execCommand('copy');
    });
  }

  // ─── CAMERA ────────────────────────────────────────────────────────────────
  async function startCamera(rear = true) {
    if (currentStream) {
      currentStream.getTracks().forEach(t => t.stop());
      currentStream = null;
    }

    const constraints = {
      video: {
        facingMode: rear ? { ideal: 'environment' } : { ideal: 'user' },
        width:  { ideal: 1280 },
        height: { ideal: 720 }
      },
      audio: false
    };

    try {
      currentStream = await navigator.mediaDevices.getUserMedia(constraints);
    } catch (e) {
      try {
        currentStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      } catch (e2) {
        statusEl.textContent = 'Camera access denied.';
        return;
      }
    }

    video.srcObject = currentStream;

    torchTrack = null;
    if (rear) {
      const vTrack = currentStream.getVideoTracks()[0];
      if (vTrack && typeof vTrack.getCapabilities === 'function') {
        const caps = vTrack.getCapabilities();
        if (caps.torch) torchTrack = vTrack;
      }
    }

    await new Promise((resolve, reject) => {
      video.onloadedmetadata = async () => {
        try { await video.play(); resolve(); }
        catch(e) { reject(e); }
      };
      video.onerror = reject;
    });

    await new Promise(r => requestAnimationFrame(r));
    syncSizes();
    statusEl.textContent = 'Camera ready. Scanning...';
    document.body.classList.add('scanning');
    startOCRLoop();
  }

  function syncSizes() {
    const vw = video.videoWidth  || 640;
    const vh = video.videoHeight || 480;
    const displayW = wrapper.offsetWidth;

    // Uncapped height based on video aspect ratio
    let displayH = Math.round(displayW * vh / vw);

    // In portrait orientation, cap video height so controls + output
    // are never pushed off screen. 42vh leaves enough room for buttons
    // and the value field regardless of phone size.
    const isPortrait = window.innerHeight > window.innerWidth;
    const maxH = isPortrait
      ? Math.floor(window.innerHeight * 0.42)
      : Math.floor(window.innerHeight * 0.72);

    if (displayH > maxH) displayH = maxH;

    wrapper.style.height = displayH + 'px';
    video.style.height   = displayH + 'px';
    overlay.width  = displayW;
    overlay.height = displayH;
    canvas.width   = vw;
    canvas.height  = vh;
  }

  function switchCamera() {
    usingRear = !usingRear;
    torchOn = false;
    selectedBox = null;
    document.getElementById('btn-torch').classList.remove('active');
    startCamera(usingRear);
  }

  async function toggleTorch() {
    if (!torchTrack) { statusEl.textContent = 'Torch not supported.'; return; }
    torchOn = !torchOn;
    try {
      await torchTrack.applyConstraints({ advanced: [{ torch: torchOn }] });
      document.getElementById('btn-torch').classList.toggle('active', torchOn);
    } catch(e) {
      statusEl.textContent = 'Could not toggle torch.';
    }
  }

  function togglePause() {
    paused = !paused;
    const btn = document.getElementById('btn-pause');
    btn.textContent = paused ? '▶ Resume' : '⏸ Pause';
    if (!paused) {
      // Resume — keep selectedBox and keep overlay as-is so the
      // highlighted box stays visible until the next scan redraws it.
      boxes = [];
      statusEl.textContent = 'Scanning...';
      hintEl.textContent = selectedBox
        ? `Looking for "${selectedBox.text}" again...`
        : 'Tap a box on the camera to select a number';
      document.body.classList.add('scanning');
    } else {
      statusEl.textContent = 'Paused.';
      document.body.classList.remove('scanning');
    }
  }

  // ─── OCR LOOP ──────────────────────────────────────────────────────────────
  // Interval is 4200ms (original 2200ms + 2000ms extra as requested)
  function startOCRLoop() {
    if (ocrInterval) clearInterval(ocrInterval);
    ocrInterval = setInterval(readDigits, 4200);
    readDigits();
  }

  async function readDigits() {
    if (processing || paused) return;
    if (!video.videoWidth || video.readyState < 2) return;

    processing = true;
    statusEl.textContent = 'Scanning';
    document.body.classList.add('scanning');

    try {
      canvas.width  = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.drawImage(video, 0, 0);

      // Grayscale
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const d = imageData.data;
      for (let i = 0; i < d.length; i += 4) {
        const g = d[i] * 0.299 + d[i+1] * 0.587 + d[i+2] * 0.114;
        d[i] = d[i+1] = d[i+2] = g;
      }
      ctx.putImageData(imageData, 0, 0);

      const result = await Tesseract.recognize(canvas, 'eng', {
        tessedit_char_whitelist: '0123456789.',
        tessedit_pageseg_mode: '11',
      });

      syncSizes();
      ctxOv.clearRect(0, 0, overlay.width, overlay.height);
      boxes = [];

      const scaleX = overlay.width  / canvas.width;
      const scaleY = overlay.height / canvas.height;

      if (result.data.words) {
        result.data.words.forEach(word => {
          const wText = word.text.trim();
          if (/^[0-9.]+$/.test(wText)) {
            const { x0, y0, x1, y1 } = word.bbox;
            const sx = x0 * scaleX;
            const sy = y0 * scaleY;
            const sw = (x1 - x0) * scaleX;
            const sh = (y1 - y0) * scaleY;
            boxes.push({ text: wText, x: sx, y: sy, width: sw, height: sh });
          }
        });
      }

      // Re-draw all boxes; highlight the selected one if it still exists
      redrawBoxes();

      // If user had a selected box, try to match it by text to update the value field
      if (selectedBox) {
        const stillExists = boxes.find(b => b.text === selectedBox.text);
        if (stillExists) {
          // Only update if user hasn't manually edited the field
          if (!outputEl.dataset.manualEdit) {
            outputEl.value = stillExists.text;
          }
          selectedBox = stillExists;
        }
        // If it disappeared, keep last value — don't clear
        statusEl.textContent = boxes.length
          ? `${boxes.length} number${boxes.length > 1 ? 's' : ''} found — tap to change selection`
          : 'Display lost — holding last value';
      } else {
        // Nothing selected yet — show hint
        statusEl.textContent = boxes.length
          ? `${boxes.length} number${boxes.length > 1 ? 's' : ''} found — tap a box to select`
          : 'No numbers detected';
        hintEl.textContent = boxes.length
          ? 'Tap a highlighted box to lock onto that value'
          : 'Tap a box on the camera to select a number';

        // Do NOT auto-populate output — wait for user tap
      }

      document.body.classList.remove('scanning');

    } catch (e) {
      statusEl.textContent = 'OCR error. Retrying...';
      console.error(e);
    }

    processing = false;
  }

  // ─── DRAW BOXES ────────────────────────────────────────────────────────────
  function redrawBoxes() {
    ctxOv.clearRect(0, 0, overlay.width, overlay.height);
    boxes.forEach(box => {
      const isSelected = selectedBox && box === selectedBox;
      ctxOv.strokeStyle = isSelected ? '#ffff00' : '#00ff88';
      ctxOv.lineWidth   = isSelected ? 3 : 2;
      ctxOv.strokeRect(box.x, box.y, box.width, box.height);
      ctxOv.fillStyle = isSelected ? '#ffff00' : '#00ff88';
      ctxOv.font      = '13px Courier New';
      ctxOv.fillText(box.text, box.x + 2, box.y > 14 ? box.y - 4 : box.y + box.height + 14);
    });
  }

  // Draw just the selected box directly onto the overlay (used after pause)
  function drawSelectedBox() {
    if (!selectedBox) return;
    ctxOv.strokeStyle = '#ffff00';
    ctxOv.lineWidth   = 3;
    ctxOv.strokeRect(selectedBox.x, selectedBox.y, selectedBox.width, selectedBox.height);
    ctxOv.fillStyle = '#ffff00';
    ctxOv.font      = '13px Courier New';
    ctxOv.fillText(selectedBox.text, selectedBox.x + 2,
      selectedBox.y > 14 ? selectedBox.y - 4 : selectedBox.y + selectedBox.height + 14);
  }

  // ─── TAP SELECTION ─────────────────────────────────────────────────────────
  function handleTap(clientX, clientY) {
    const rect = overlay.getBoundingClientRect();
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    let hit = false;
    boxes.forEach(box => {
      if (x >= box.x && x <= box.x + box.width &&
          y >= box.y && y <= box.y + box.height) {

        selectedBox = box;
        outputEl.value = box.text;
        delete outputEl.dataset.manualEdit;

        // Auto-pause so the value stays frozen until user resumes
        if (!paused) {
          paused = true;
          document.getElementById('btn-pause').textContent = '▶ Resume';
          document.body.classList.remove('scanning');
        }

        // Clear overlay and redraw only the selected box in yellow
        ctxOv.clearRect(0, 0, overlay.width, overlay.height);
        drawSelectedBox();

        hintEl.textContent = `Locked to "${box.text}" — tap ▶ Resume to scan again`;
        statusEl.textContent = 'Paused — selection locked ✓';
        hit = true;
      }
    });

    if (!hit && boxes.length === 0) {
      // Tapped dead air with no boxes — do nothing, keep last value
    }
  }

  // Track if user manually edits the field so we don't overwrite their edit
  outputEl.addEventListener('input', () => {
    outputEl.dataset.manualEdit = '1';
    hintEl.textContent = 'Manually edited — OCR updates paused for this value';
    if (meters[currentMeter]) meters[currentMeter].value = outputEl.value;
  });

  outputEl.addEventListener('change', () => {
    if (outputEl.value.trim() === '') {
      delete outputEl.dataset.manualEdit;
      selectedBox = null;
      hintEl.textContent = 'Tap a box on the camera to select a number';
    }
    if (meters[currentMeter]) meters[currentMeter].value = outputEl.value;
    const dot = document.getElementById(`dot-${currentMeter}`);
    if (dot) dot.classList.toggle('has-value', !!outputEl.value.trim());
  });

  overlay.addEventListener('click', e => handleTap(e.clientX, e.clientY));
  overlay.addEventListener('touchend', e => {
    e.preventDefault();
    const t = e.changedTouches[0];
    handleTap(t.clientX, t.clientY);
  }, { passive: false });

  // ─── RESIZE ────────────────────────────────────────────────────────────────
  // resize covers most cases; orientationchange fires on Android
  // with a small delay to let the browser finish rotating first
  function onLayoutChange() {
    setTimeout(() => {
      syncSizes();
      redrawBoxes();
    }, 120);
  }

  window.addEventListener('resize', onLayoutChange);
  window.addEventListener('orientationchange', onLayoutChange);

  // ─── INIT: show setup page first ───────────────────────────────────────────
  buildSetupPage();
</script>
</body>
</html>
