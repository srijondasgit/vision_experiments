<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Digit Detection</title>
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: Arial; background: #1a1a1a; color: #eee; display: flex; flex-direction: column; align-items: center; padding: 20px; }
  h2 { margin-bottom: 16px; letter-spacing: 2px; color: #FFD700; }

  #result-number {
    font-size: 52px;
    font-weight: bold;
    letter-spacing: 10px;
    color: #FFD700;
    background: #111;
    border: 2px solid #333;
    border-radius: 12px;
    padding: 14px 36px;
    margin-bottom: 16px;
    min-width: 220px;
    text-align: center;
  }

  #digit-row {
    display: flex;
    gap: 8px;
    margin-bottom: 16px;
    flex-wrap: wrap;
    justify-content: center;
  }
  .digit-card {
    background: #222;
    border: 2px solid #444;
    border-radius: 8px;
    padding: 8px 14px;
    text-align: center;
    min-width: 54px;
  }
  .digit-card .digit { font-size: 28px; font-weight: bold; }
  .digit-card .conf  { font-size: 11px; color: #aaa; margin-top: 2px; }

  canvas { border: 2px solid #444; max-width: 100%; border-radius: 6px; }
  #log { font-size: 13px; color: #888; margin-top: 10px; }
</style>
</head>
<body>

<h2>Digit Detection</h2>
<div id="result-number">—</div>
<div id="digit-row"></div>
<canvas id="canvas"></canvas>
<div id="log">Loading model...</div>

<script>
// ─── CONFIG ──────────────────────────────────────────
const MODEL_PATH     = "best.onnx";
const IMAGE_PATH     = "img1.jpeg";
const MODEL_INPUT    = 576;
const CONF_THRESHOLD = 0.25;
const IOU_THRESHOLD  = 0.45;
const CLASS_NAMES    = ["-","0","1","2","3","4","5","6","7","8","9"]; // 11 classes
// ─────────────────────────────────────────────────────

const logEl    = document.getElementById("log");
const resultEl = document.getElementById("result-number");
const rowEl    = document.getElementById("digit-row");
const log = msg => { console.log(msg); logEl.innerText = msg; };

function iou(a, b) {
  const x1 = Math.max(a.x1, b.x1), y1 = Math.max(a.y1, b.y1);
  const x2 = Math.min(a.x2, b.x2), y2 = Math.min(a.y2, b.y2);
  const inter = Math.max(0, x2-x1) * Math.max(0, y2-y1);
  const areaA = (a.x2-a.x1) * (a.y2-a.y1);
  const areaB = (b.x2-b.x1) * (b.y2-b.y1);
  return inter / (areaA + areaB - inter + 1e-6);
}

function nms(boxes) {
  boxes.sort((a, b) => b.score - a.score);
  const keep = [];
  while (boxes.length) {
    const best = boxes.shift();
    keep.push(best);
    boxes = boxes.filter(b => iou(best, b) < IOU_THRESHOLD);
  }
  return keep;
}

function letterbox(img, size) {
  const c   = document.createElement("canvas");
  c.width   = c.height = size;
  const ctx = c.getContext("2d");
  ctx.fillStyle = "#808080";
  ctx.fillRect(0, 0, size, size);
  const scale = Math.min(size/img.width, size/img.height);
  const nw    = Math.round(img.width  * scale);
  const nh    = Math.round(img.height * scale);
  const dx    = Math.round((size - nw) / 2);
  const dy    = Math.round((size - nh) / 2);
  ctx.drawImage(img, dx, dy, nw, nh);
  return { canvas: c, scale, dx, dy };
}

const COLORS = [
  "#AAAAAA","#FF4444","#44AAFF","#44FF88","#FFD700",
  "#FF44FF","#44FFFF","#FF8800","#88FF00","#AA44FF","#FF4488"
];

async function run() {
  log("Loading model...");
  const session = await ort.InferenceSession.create(MODEL_PATH);
  log("Model loaded ✅");

  const img = await new Promise((res, rej) => {
    const i   = new Image();
    i.onload  = () => res(i);
    i.onerror = () => rej("Image load failed");
    i.src     = IMAGE_PATH;
  });

  // Draw original on canvas
  const canvas = document.getElementById("canvas");
  const ctx    = canvas.getContext("2d");
  canvas.width  = img.width;
  canvas.height = img.height;
  ctx.drawImage(img, 0, 0);

  // Letterbox preprocess
  const { canvas: lbCanvas, scale, dx, dy } = letterbox(img, MODEL_INPUT);
  const lbCtx     = lbCanvas.getContext("2d");
  const imageData = lbCtx.getImageData(0, 0, MODEL_INPUT, MODEL_INPUT).data;
  const area      = MODEL_INPUT * MODEL_INPUT;
  const input     = new Float32Array(3 * area);
  for (let i = 0; i < area; i++) {
    input[i]          = imageData[i*4]   / 255;
    input[i + area]   = imageData[i*4+1] / 255;
    input[i + area*2] = imageData[i*4+2] / 255;
  }

  // Inference
  const tensor  = new ort.Tensor("float32", input, [1, 3, MODEL_INPUT, MODEL_INPUT]);
  const results = await session.run({ images: tensor });

  const outTensor  = results[Object.keys(results)[0]];
  const dims       = outTensor.dims;
  const output     = outTensor.data;
  const numAnchors = dims[2];
  const numClasses = dims[1] - 4;  // YOLOv8: no objectness, just 4box + classes

  console.log(`Output: [${dims}] → numClasses=${numClasses} numAnchors=${numAnchors}`);

  // Decode — YOLOv8 style (no objectness, no sigmoid needed on class scores)
  const boxes = [];
  for (let i = 0; i < numAnchors; i++) {
    let bestClass = 0, bestScore = 0;
    for (let c = 0; c < numClasses; c++) {
      const s = output[(4 + c) * numAnchors + i];
      if (s > bestScore) { bestScore = s; bestClass = c; }
    }
    if (bestScore < CONF_THRESHOLD) continue;

    const cx = output[0 * numAnchors + i];
    const cy = output[1 * numAnchors + i];
    const w  = output[2 * numAnchors + i];
    const h  = output[3 * numAnchors + i];

    const x1 = ((cx - w/2) - dx) / scale;
    const y1 = ((cy - h/2) - dy) / scale;
    const x2 = ((cx + w/2) - dx) / scale;
    const y2 = ((cy + h/2) - dy) / scale;

    boxes.push({
      x1: Math.max(0, x1),
      y1: Math.max(0, y1),
      x2: Math.min(img.width,  x2),
      y2: Math.min(img.height, y2),
      score   : bestScore,
      label   : CLASS_NAMES[bestClass] ?? String(bestClass),
      classIdx: bestClass
    });
  }

  // NMS → sort left to right
  const finalBoxes = nms(boxes).sort((a, b) => a.x1 - b.x1);
  console.log("Final detections:", finalBoxes.length);

  // Full number string
  const fullNumber = finalBoxes.map(b => b.label).join("");
  resultEl.textContent = fullNumber || "—";
  log(`Detected ${finalBoxes.length} digit(s)  →  ${fullNumber}`);

  // Digit cards
  rowEl.innerHTML = "";
  finalBoxes.forEach(b => {
    const color = COLORS[b.classIdx % COLORS.length];
    const card  = document.createElement("div");
    card.className = "digit-card";
    card.style.borderColor = color;
    card.innerHTML = `
      <div class="digit" style="color:${color}">${b.label}</div>
      <div class="conf">${(b.score * 100).toFixed(1)}%</div>
    `;
    rowEl.appendChild(card);
  });

  // Draw boxes on canvas
  finalBoxes.forEach(b => {
    const color = COLORS[b.classIdx % COLORS.length];
    const bw    = b.x2 - b.x1;
    const bh    = b.y2 - b.y1;

    ctx.strokeStyle = color;
    ctx.lineWidth   = 2;
    ctx.strokeRect(b.x1, b.y1, bw, bh);

    const text = `${b.label} ${(b.score*100).toFixed(0)}%`;
    ctx.font   = "bold 15px Arial";
    const tw   = ctx.measureText(text).width;
    const th   = 18;
    const lx   = b.x1;
    const ly   = b.y1 > th+2 ? b.y1-th-2 : b.y1+bh+2;

    ctx.fillStyle = color;
    ctx.fillRect(lx, ly, tw+8, th+4);
    ctx.fillStyle = "#000";
    ctx.fillText(text, lx+4, ly+th);
  });
}

run().catch(e => log("❌ " + e));
</script>
</body>
</html>
